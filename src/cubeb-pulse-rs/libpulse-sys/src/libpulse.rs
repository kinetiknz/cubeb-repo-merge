use libc::*;
pub type Struct_timeval = timeval;

/* automatically generated by rust-bindgen */

pub type Enum_pa_sample_format = c_int;
pub const PA_SAMPLE_U8: c_int = 0;
pub const PA_SAMPLE_ALAW: c_int = 1;
pub const PA_SAMPLE_ULAW: c_int = 2;
pub const PA_SAMPLE_S16LE: c_int = 3;
pub const PA_SAMPLE_S16BE: c_int = 4;
pub const PA_SAMPLE_FLOAT32LE: c_int = 5;
pub const PA_SAMPLE_FLOAT32BE: c_int = 6;
pub const PA_SAMPLE_S32LE: c_int = 7;
pub const PA_SAMPLE_S32BE: c_int = 8;
pub const PA_SAMPLE_S24LE: c_int = 9;
pub const PA_SAMPLE_S24BE: c_int = 10;
pub const PA_SAMPLE_S24_32LE: c_int = 11;
pub const PA_SAMPLE_S24_32BE: c_int = 12;
pub const PA_SAMPLE_MAX: c_int = 13;
pub const PA_SAMPLE_INVALID: c_int = -1;
pub type pa_sample_format_t = Enum_pa_sample_format;
#[repr(C)]
#[derive(Copy,Clone,Debug)]
pub struct Struct_pa_sample_spec {
    pub format: pa_sample_format_t,
    pub rate: uint32_t,
    pub channels: uint8_t,
}
impl ::std::default::Default for Struct_pa_sample_spec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_sample_spec = Struct_pa_sample_spec;
pub type pa_usec_t = uint64_t;
pub type Enum_pa_context_state = c_int;
pub const PA_CONTEXT_UNCONNECTED: c_int = 0;
pub const PA_CONTEXT_CONNECTING: c_int = 1;
pub const PA_CONTEXT_AUTHORIZING: c_int = 2;
pub const PA_CONTEXT_SETTING_NAME: c_int = 3;
pub const PA_CONTEXT_READY: c_int = 4;
pub const PA_CONTEXT_FAILED: c_int = 5;
pub const PA_CONTEXT_TERMINATED: c_int = 6;
pub type pa_context_state_t = Enum_pa_context_state;
#[allow(non_snake_case)]
pub fn PA_CONTEXT_IS_GOOD(x: pa_context_state_t) -> bool {
    x == PA_CONTEXT_CONNECTING ||
    x == PA_CONTEXT_AUTHORIZING ||
    x == PA_CONTEXT_SETTING_NAME ||
    x == PA_CONTEXT_READY
}
pub type Enum_pa_stream_state = c_int;
pub const PA_STREAM_UNCONNECTED: c_int = 0;
pub const PA_STREAM_CREATING: c_int = 1;
pub const PA_STREAM_READY: c_int = 2;
pub const PA_STREAM_FAILED: c_int = 3;
pub const PA_STREAM_TERMINATED: c_int = 4;
pub type pa_stream_state_t = Enum_pa_stream_state;
#[allow(non_snake_case)]
pub fn PA_STREAM_IS_GOOD(x: pa_stream_state_t) -> bool {
    x == PA_STREAM_CREATING ||
    x == PA_STREAM_READY
}
pub type Enum_pa_operation_state = c_int;
pub const PA_OPERATION_RUNNING: c_int = 0;
pub const PA_OPERATION_DONE: c_int = 1;
pub const PA_OPERATION_CANCELLED: c_int = 2;
pub type pa_operation_state_t = Enum_pa_operation_state;
pub type Enum_pa_context_flags = c_int;
pub const PA_CONTEXT_NOFLAGS: c_int = 0;
pub const PA_CONTEXT_NOAUTOSPAWN: c_int = 1;
pub const PA_CONTEXT_NOFAIL: c_int = 2;
pub type pa_context_flags_t = Enum_pa_context_flags;
pub type Enum_pa_direction = c_int;
pub const PA_DIRECTION_OUTPUT: c_int = 1;
pub const PA_DIRECTION_INPUT: c_int = 2;
pub type pa_direction_t = Enum_pa_direction;
pub type Enum_pa_device_type = c_int;
pub const PA_DEVICE_TYPE_SINK: c_int = 0;
pub const PA_DEVICE_TYPE_SOURCE: c_int = 1;
pub type pa_device_type_t = Enum_pa_device_type;
pub type Enum_pa_stream_direction = c_int;
pub const PA_STREAM_NODIRECTION: c_int = 0;
pub const PA_STREAM_PLAYBACK: c_int = 1;
pub const PA_STREAM_RECORD: c_int = 2;
pub const PA_STREAM_UPLOAD: c_int = 3;
pub type pa_stream_direction_t = Enum_pa_stream_direction;
pub type Enum_pa_stream_flags = c_int;
pub const PA_STREAM_NOFLAGS: c_int = 0;
pub const PA_STREAM_START_CORKED: c_int = 1;
pub const PA_STREAM_INTERPOLATE_TIMING: c_int = 2;
pub const PA_STREAM_NOT_MONOTONIC: c_int = 4;
pub const PA_STREAM_AUTO_TIMING_UPDATE: c_int = 8;
pub const PA_STREAM_NO_REMAP_CHANNELS: c_int = 16;
pub const PA_STREAM_NO_REMIX_CHANNELS: c_int = 32;
pub const PA_STREAM_FIX_FORMAT: c_int = 64;
pub const PA_STREAM_FIX_RATE: c_int = 128;
pub const PA_STREAM_FIX_CHANNELS: c_int = 256;
pub const PA_STREAM_DONT_MOVE: c_int = 512;
pub const PA_STREAM_VARIABLE_RATE: c_int = 1024;
pub const PA_STREAM_PEAK_DETECT: c_int = 2048;
pub const PA_STREAM_START_MUTED: c_int = 4096;
pub const PA_STREAM_ADJUST_LATENCY: c_int = 8192;
pub const PA_STREAM_EARLY_REQUESTS: c_int = 16384;
pub const PA_STREAM_DONT_INHIBIT_AUTO_SUSPEND: c_int = 32768;
pub const PA_STREAM_START_UNMUTED: c_int = 65536;
pub const PA_STREAM_FAIL_ON_SUSPEND: c_int = 131072;
pub const PA_STREAM_RELATIVE_VOLUME: c_int = 262144;
pub const PA_STREAM_PASSTHROUGH: c_int = 524288;
pub type pa_stream_flags_t = Enum_pa_stream_flags;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_buffer_attr {
    pub maxlength: uint32_t,
    pub tlength: uint32_t,
    pub prebuf: uint32_t,
    pub minreq: uint32_t,
    pub fragsize: uint32_t,
}
impl ::std::clone::Clone for Struct_pa_buffer_attr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_buffer_attr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_buffer_attr = Struct_pa_buffer_attr;
pub type Enum_pa_error_code = c_int;
pub const PA_OK: c_int = 0;
pub const PA_ERR_ACCESS: c_int = 1;
pub const PA_ERR_COMMAND: c_int = 2;
pub const PA_ERR_INVALID: c_int = 3;
pub const PA_ERR_EXIST: c_int = 4;
pub const PA_ERR_NOENTITY: c_int = 5;
pub const PA_ERR_CONNECTIONREFUSED: c_int = 6;
pub const PA_ERR_PROTOCOL: c_int = 7;
pub const PA_ERR_TIMEOUT: c_int = 8;
pub const PA_ERR_AUTHKEY: c_int = 9;
pub const PA_ERR_INTERNAL: c_int = 10;
pub const PA_ERR_CONNECTIONTERMINATED: c_int = 11;
pub const PA_ERR_KILLED: c_int = 12;
pub const PA_ERR_INVALIDSERVER: c_int = 13;
pub const PA_ERR_MODINITFAILED: c_int = 14;
pub const PA_ERR_BADSTATE: c_int = 15;
pub const PA_ERR_NODATA: c_int = 16;
pub const PA_ERR_VERSION: c_int = 17;
pub const PA_ERR_TOOLARGE: c_int = 18;
pub const PA_ERR_NOTSUPPORTED: c_int = 19;
pub const PA_ERR_UNKNOWN: c_int = 20;
pub const PA_ERR_NOEXTENSION: c_int = 21;
pub const PA_ERR_OBSOLETE: c_int = 22;
pub const PA_ERR_NOTIMPLEMENTED: c_int = 23;
pub const PA_ERR_FORKED: c_int = 24;
pub const PA_ERR_IO: c_int = 25;
pub const PA_ERR_BUSY: c_int = 26;
pub const PA_ERR_MAX: c_int = 27;
pub type pa_error_code_t = Enum_pa_error_code;
pub type Enum_pa_subscription_mask = c_int;
pub const PA_SUBSCRIPTION_MASK_NULL: c_int = 0;
pub const PA_SUBSCRIPTION_MASK_SINK: c_int = 1;
pub const PA_SUBSCRIPTION_MASK_SOURCE: c_int = 2;
pub const PA_SUBSCRIPTION_MASK_SINK_INPUT: c_int = 4;
pub const PA_SUBSCRIPTION_MASK_SOURCE_OUTPUT: c_int = 8;
pub const PA_SUBSCRIPTION_MASK_MODULE: c_int = 16;
pub const PA_SUBSCRIPTION_MASK_CLIENT: c_int = 32;
pub const PA_SUBSCRIPTION_MASK_SAMPLE_CACHE: c_int = 64;
pub const PA_SUBSCRIPTION_MASK_SERVER: c_int = 128;
pub const PA_SUBSCRIPTION_MASK_AUTOLOAD: c_int = 256;
pub const PA_SUBSCRIPTION_MASK_CARD: c_int = 512;
pub const PA_SUBSCRIPTION_MASK_ALL: c_int = 767;
pub type pa_subscription_mask_t = Enum_pa_subscription_mask;
pub type Enum_pa_subscription_event_type = c_int;
pub const PA_SUBSCRIPTION_EVENT_SINK: c_int = 0;
pub const PA_SUBSCRIPTION_EVENT_SOURCE: c_int = 1;
pub const PA_SUBSCRIPTION_EVENT_SINK_INPUT: c_int = 2;
pub const PA_SUBSCRIPTION_EVENT_SOURCE_OUTPUT: c_int = 3;
pub const PA_SUBSCRIPTION_EVENT_MODULE: c_int = 4;
pub const PA_SUBSCRIPTION_EVENT_CLIENT: c_int = 5;
pub const PA_SUBSCRIPTION_EVENT_SAMPLE_CACHE: c_int = 6;
pub const PA_SUBSCRIPTION_EVENT_SERVER: c_int = 7;
pub const PA_SUBSCRIPTION_EVENT_AUTOLOAD: c_int = 8;
pub const PA_SUBSCRIPTION_EVENT_CARD: c_int = 9;
pub const PA_SUBSCRIPTION_EVENT_FACILITY_MASK: c_int = 15;
pub const PA_SUBSCRIPTION_EVENT_NEW: c_int = 0;
pub const PA_SUBSCRIPTION_EVENT_CHANGE: c_int = 16;
pub const PA_SUBSCRIPTION_EVENT_REMOVE: c_int = 32;
pub const PA_SUBSCRIPTION_EVENT_TYPE_MASK: c_int = 48;
pub type pa_subscription_event_type_t = Enum_pa_subscription_event_type;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_timing_info {
    pub timestamp: Struct_timeval,
    pub synchronized_clocks: c_int,
    pub sink_usec: pa_usec_t,
    pub source_usec: pa_usec_t,
    pub transport_usec: pa_usec_t,
    pub playing: c_int,
    pub write_index_corrupt: c_int,
    pub write_index: int64_t,
    pub read_index_corrupt: c_int,
    pub read_index: int64_t,
    pub configured_sink_usec: pa_usec_t,
    pub configured_source_usec: pa_usec_t,
    pub since_underrun: int64_t,
}
impl ::std::clone::Clone for Struct_pa_timing_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_timing_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_timing_info = Struct_pa_timing_info;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_spawn_api {
    pub prefork: ::std::option::Option<extern "C" fn() -> ()>,
    pub postfork: ::std::option::Option<extern "C" fn() -> ()>,
    pub atfork: ::std::option::Option<extern "C" fn() -> ()>,
}
impl ::std::clone::Clone for Struct_pa_spawn_api {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_spawn_api {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_spawn_api = Struct_pa_spawn_api;
pub type Enum_pa_seek_mode = c_int;
pub const PA_SEEK_RELATIVE: c_int = 0;
pub const PA_SEEK_ABSOLUTE: c_int = 1;
pub const PA_SEEK_RELATIVE_ON_READ: c_int = 2;
pub const PA_SEEK_RELATIVE_END: c_int = 3;
pub type pa_seek_mode_t = Enum_pa_seek_mode;
pub type Enum_pa_sink_flags = c_int;
pub const PA_SINK_NOFLAGS: c_int = 0;
pub const PA_SINK_HW_VOLUME_CTRL: c_int = 1;
pub const PA_SINK_LATENCY: c_int = 2;
pub const PA_SINK_HARDWARE: c_int = 4;
pub const PA_SINK_NETWORK: c_int = 8;
pub const PA_SINK_HW_MUTE_CTRL: c_int = 16;
pub const PA_SINK_DECIBEL_VOLUME: c_int = 32;
pub const PA_SINK_FLAT_VOLUME: c_int = 64;
pub const PA_SINK_DYNAMIC_LATENCY: c_int = 128;
pub const PA_SINK_SET_FORMATS: c_int = 256;
pub type pa_sink_flags_t = Enum_pa_sink_flags;
pub type Enum_pa_sink_state = c_int;
pub const PA_SINK_INVALID_STATE: c_int = -1;
pub const PA_SINK_RUNNING: c_int = 0;
pub const PA_SINK_IDLE: c_int = 1;
pub const PA_SINK_SUSPENDED: c_int = 2;
pub const PA_SINK_INIT: c_int = -2;
pub const PA_SINK_UNLINKED: c_int = -3;
pub type pa_sink_state_t = Enum_pa_sink_state;
pub type Enum_pa_source_flags = c_int;
pub const PA_SOURCE_NOFLAGS: c_int = 0;
pub const PA_SOURCE_HW_VOLUME_CTRL: c_int = 1;
pub const PA_SOURCE_LATENCY: c_int = 2;
pub const PA_SOURCE_HARDWARE: c_int = 4;
pub const PA_SOURCE_NETWORK: c_int = 8;
pub const PA_SOURCE_HW_MUTE_CTRL: c_int = 16;
pub const PA_SOURCE_DECIBEL_VOLUME: c_int = 32;
pub const PA_SOURCE_DYNAMIC_LATENCY: c_int = 64;
pub const PA_SOURCE_FLAT_VOLUME: c_int = 128;
pub type pa_source_flags_t = Enum_pa_source_flags;
pub type Enum_pa_source_state = c_int;
pub const PA_SOURCE_INVALID_STATE: c_int = -1;
pub const PA_SOURCE_RUNNING: c_int = 0;
pub const PA_SOURCE_IDLE: c_int = 1;
pub const PA_SOURCE_SUSPENDED: c_int = 2;
pub const PA_SOURCE_INIT: c_int = -2;
pub const PA_SOURCE_UNLINKED: c_int = -3;
pub type pa_source_state_t = Enum_pa_source_state;
pub type pa_free_cb_t =
    ::std::option::Option<unsafe extern "C" fn(p: *mut c_void) -> ()>;
pub type Enum_pa_port_available = c_int;
pub const PA_PORT_AVAILABLE_UNKNOWN: c_int = 0;
pub const PA_PORT_AVAILABLE_NO: c_int = 1;
pub const PA_PORT_AVAILABLE_YES: c_int = 2;
pub type pa_port_available_t = Enum_pa_port_available;
pub type pa_mainloop_api = Struct_pa_mainloop_api;
pub type Enum_pa_io_event_flags = c_int;
pub const PA_IO_EVENT_NULL: c_int = 0;
pub const PA_IO_EVENT_INPUT: c_int = 1;
pub const PA_IO_EVENT_OUTPUT: c_int = 2;
pub const PA_IO_EVENT_HANGUP: c_int = 4;
pub const PA_IO_EVENT_ERROR: c_int = 8;
pub type pa_io_event_flags_t = Enum_pa_io_event_flags;
pub enum Struct_pa_io_event { }
pub type pa_io_event = Struct_pa_io_event;
pub type pa_io_event_cb_t =
    ::std::option::Option<unsafe extern "C" fn(ea: *mut pa_mainloop_api,
                                               e: *mut pa_io_event,
                                               fd: c_int,
                                               events: pa_io_event_flags_t,
                                               userdata: *mut c_void)
                              -> ()>;
pub type pa_io_event_destroy_cb_t =
    ::std::option::Option<unsafe extern "C" fn(a: *mut pa_mainloop_api,
                                               e: *mut pa_io_event,
                                               userdata: *mut c_void)
                              -> ()>;
pub enum Struct_pa_time_event { }
pub type pa_time_event = Struct_pa_time_event;
pub type pa_time_event_cb_t =
    ::std::option::Option<unsafe extern "C" fn(a: *mut pa_mainloop_api,
                                               e: *mut pa_time_event,
                                               tv: *const Struct_timeval,
                                               userdata: *mut c_void)
                              -> ()>;
pub type pa_time_event_destroy_cb_t =
    ::std::option::Option<unsafe extern "C" fn(a: *mut pa_mainloop_api,
                                               e: *mut pa_time_event,
                                               userdata: *mut c_void)
                              -> ()>;
pub enum Struct_pa_defer_event { }
pub type pa_defer_event = Struct_pa_defer_event;
pub type pa_defer_event_cb_t =
    ::std::option::Option<unsafe extern "C" fn(a: *mut pa_mainloop_api,
                                               e: *mut pa_defer_event,
                                               userdata: *mut c_void)
                              -> ()>;
pub type pa_defer_event_destroy_cb_t =
    ::std::option::Option<unsafe extern "C" fn(a: *mut pa_mainloop_api,
                                               e: *mut pa_defer_event,
                                               userdata: *mut c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_mainloop_api {
    pub userdata: *mut c_void,
    pub io_new: ::std::option::Option<unsafe extern "C" fn(a:
                                                               *mut pa_mainloop_api,
                                                           fd: c_int,
                                                           events:
                                                               pa_io_event_flags_t,
                                                           cb:
                                                               pa_io_event_cb_t,
                                                           userdata:
                                                               *mut c_void)
                                          -> *mut pa_io_event>,
    pub io_enable: ::std::option::Option<unsafe extern "C" fn(e:
                                                                  *mut pa_io_event,
                                                              events:
                                                                  pa_io_event_flags_t)
                                             -> ()>,
    pub io_free: ::std::option::Option<unsafe extern "C" fn(e:
                                                                *mut pa_io_event)
                                           -> ()>,
    pub io_set_destroy: ::std::option::Option<unsafe extern "C" fn(e:
                                                                       *mut pa_io_event,
                                                                   cb:
                                                                       pa_io_event_destroy_cb_t)
                                                  -> ()>,
    pub time_new: ::std::option::Option<unsafe extern "C" fn(a:
                                                                 *mut pa_mainloop_api,
                                                             tv:
                                                                 *const Struct_timeval,
                                                             cb:
                                                                 pa_time_event_cb_t,
                                                             userdata:
                                                                 *mut c_void)
                                            -> *mut pa_time_event>,
    pub time_restart: ::std::option::Option<unsafe extern "C" fn(e:
                                                                     *mut pa_time_event,
                                                                 tv:
                                                                     *const Struct_timeval)
                                                -> ()>,
    pub time_free: ::std::option::Option<unsafe extern "C" fn(e:
                                                                  *mut pa_time_event)
                                             -> ()>,
    pub time_set_destroy: ::std::option::Option<unsafe extern "C" fn(e:
                                                                         *mut pa_time_event,
                                                                     cb:
                                                                         pa_time_event_destroy_cb_t)
                                                    -> ()>,
    pub defer_new: ::std::option::Option<unsafe extern "C" fn(a:
                                                                  *mut pa_mainloop_api,
                                                              cb:
                                                                  pa_defer_event_cb_t,
                                                              userdata:
                                                                  *mut c_void)
                                             -> *mut pa_defer_event>,
    pub defer_enable: ::std::option::Option<unsafe extern "C" fn(e:
                                                                     *mut pa_defer_event,
                                                                 b:
                                                                     c_int)
                                                -> ()>,
    pub defer_free: ::std::option::Option<unsafe extern "C" fn(e:
                                                                   *mut pa_defer_event)
                                              -> ()>,
    pub defer_set_destroy: ::std::option::Option<unsafe extern "C" fn(e:
                                                                          *mut pa_defer_event,
                                                                      cb:
                                                                          pa_defer_event_destroy_cb_t)
                                                     -> ()>,
    pub quit: ::std::option::Option<unsafe extern "C" fn(a:
                                                             *mut pa_mainloop_api,
                                                         retval:
                                                             c_int)
                                        -> ()>,
}
impl ::std::clone::Clone for Struct_pa_mainloop_api {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_mainloop_api {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_pa_proplist { }
pub type pa_proplist = Struct_pa_proplist;
pub type Enum_pa_update_mode = c_int;
pub const PA_UPDATE_SET: c_int = 0;
pub const PA_UPDATE_MERGE: c_int = 1;
pub const PA_UPDATE_REPLACE: c_int = 2;
pub type pa_update_mode_t = Enum_pa_update_mode;
pub type Enum_pa_channel_position = c_int;
pub const PA_CHANNEL_POSITION_INVALID: c_int = -1;
pub const PA_CHANNEL_POSITION_MONO: c_int = 0;
pub const PA_CHANNEL_POSITION_FRONT_LEFT: c_int = 1;
pub const PA_CHANNEL_POSITION_FRONT_RIGHT: c_int = 2;
pub const PA_CHANNEL_POSITION_FRONT_CENTER: c_int = 3;
pub const PA_CHANNEL_POSITION_LEFT: c_int = 1;
pub const PA_CHANNEL_POSITION_RIGHT: c_int = 2;
pub const PA_CHANNEL_POSITION_CENTER: c_int = 3;
pub const PA_CHANNEL_POSITION_REAR_CENTER: c_int = 4;
pub const PA_CHANNEL_POSITION_REAR_LEFT: c_int = 5;
pub const PA_CHANNEL_POSITION_REAR_RIGHT: c_int = 6;
pub const PA_CHANNEL_POSITION_LFE: c_int = 7;
pub const PA_CHANNEL_POSITION_SUBWOOFER: c_int = 7;
pub const PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER: c_int = 8;
pub const PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER: c_int = 9;
pub const PA_CHANNEL_POSITION_SIDE_LEFT: c_int = 10;
pub const PA_CHANNEL_POSITION_SIDE_RIGHT: c_int = 11;
pub const PA_CHANNEL_POSITION_AUX0: c_int = 12;
pub const PA_CHANNEL_POSITION_AUX1: c_int = 13;
pub const PA_CHANNEL_POSITION_AUX2: c_int = 14;
pub const PA_CHANNEL_POSITION_AUX3: c_int = 15;
pub const PA_CHANNEL_POSITION_AUX4: c_int = 16;
pub const PA_CHANNEL_POSITION_AUX5: c_int = 17;
pub const PA_CHANNEL_POSITION_AUX6: c_int = 18;
pub const PA_CHANNEL_POSITION_AUX7: c_int = 19;
pub const PA_CHANNEL_POSITION_AUX8: c_int = 20;
pub const PA_CHANNEL_POSITION_AUX9: c_int = 21;
pub const PA_CHANNEL_POSITION_AUX10: c_int = 22;
pub const PA_CHANNEL_POSITION_AUX11: c_int = 23;
pub const PA_CHANNEL_POSITION_AUX12: c_int = 24;
pub const PA_CHANNEL_POSITION_AUX13: c_int = 25;
pub const PA_CHANNEL_POSITION_AUX14: c_int = 26;
pub const PA_CHANNEL_POSITION_AUX15: c_int = 27;
pub const PA_CHANNEL_POSITION_AUX16: c_int = 28;
pub const PA_CHANNEL_POSITION_AUX17: c_int = 29;
pub const PA_CHANNEL_POSITION_AUX18: c_int = 30;
pub const PA_CHANNEL_POSITION_AUX19: c_int = 31;
pub const PA_CHANNEL_POSITION_AUX20: c_int = 32;
pub const PA_CHANNEL_POSITION_AUX21: c_int = 33;
pub const PA_CHANNEL_POSITION_AUX22: c_int = 34;
pub const PA_CHANNEL_POSITION_AUX23: c_int = 35;
pub const PA_CHANNEL_POSITION_AUX24: c_int = 36;
pub const PA_CHANNEL_POSITION_AUX25: c_int = 37;
pub const PA_CHANNEL_POSITION_AUX26: c_int = 38;
pub const PA_CHANNEL_POSITION_AUX27: c_int = 39;
pub const PA_CHANNEL_POSITION_AUX28: c_int = 40;
pub const PA_CHANNEL_POSITION_AUX29: c_int = 41;
pub const PA_CHANNEL_POSITION_AUX30: c_int = 42;
pub const PA_CHANNEL_POSITION_AUX31: c_int = 43;
pub const PA_CHANNEL_POSITION_TOP_CENTER: c_int = 44;
pub const PA_CHANNEL_POSITION_TOP_FRONT_LEFT: c_int = 45;
pub const PA_CHANNEL_POSITION_TOP_FRONT_RIGHT: c_int = 46;
pub const PA_CHANNEL_POSITION_TOP_FRONT_CENTER: c_int = 47;
pub const PA_CHANNEL_POSITION_TOP_REAR_LEFT: c_int = 48;
pub const PA_CHANNEL_POSITION_TOP_REAR_RIGHT: c_int = 49;
pub const PA_CHANNEL_POSITION_TOP_REAR_CENTER: c_int = 50;
pub const PA_CHANNEL_POSITION_MAX: c_int = 51;
pub type pa_channel_position_t = Enum_pa_channel_position;
pub type pa_channel_position_mask_t = uint64_t;
pub type Enum_pa_channel_map_def = c_int;
pub const PA_CHANNEL_MAP_AIFF: c_int = 0;
pub const PA_CHANNEL_MAP_ALSA: c_int = 1;
pub const PA_CHANNEL_MAP_AUX: c_int = 2;
pub const PA_CHANNEL_MAP_WAVEEX: c_int = 3;
pub const PA_CHANNEL_MAP_OSS: c_int = 4;
pub const PA_CHANNEL_MAP_DEF_MAX: c_int = 5;
pub const PA_CHANNEL_MAP_DEFAULT: c_int = 0;
pub type pa_channel_map_def_t = Enum_pa_channel_map_def;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_channel_map {
    pub channels: uint8_t,
    pub map: [pa_channel_position_t; 32usize],
}
impl ::std::clone::Clone for Struct_pa_channel_map {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_channel_map {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_channel_map = Struct_pa_channel_map;
pub type Enum_pa_encoding = c_int;
pub const PA_ENCODING_ANY: c_int = 0;
pub const PA_ENCODING_PCM: c_int = 1;
pub const PA_ENCODING_AC3_IEC61937: c_int = 2;
pub const PA_ENCODING_EAC3_IEC61937: c_int = 3;
pub const PA_ENCODING_MPEG_IEC61937: c_int = 4;
pub const PA_ENCODING_DTS_IEC61937: c_int = 5;
pub const PA_ENCODING_MPEG2_AAC_IEC61937: c_int = 6;
pub const PA_ENCODING_MAX: c_int = 7;
pub const PA_ENCODING_INVALID: c_int = -1;
pub type pa_encoding_t = Enum_pa_encoding;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_format_info {
    pub encoding: pa_encoding_t,
    pub plist: *mut pa_proplist,
}
impl ::std::clone::Clone for Struct_pa_format_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_format_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_format_info = Struct_pa_format_info;
pub type Enum_pa_prop_type_t = c_int;
pub const PA_PROP_TYPE_INT: c_int = 0;
pub const PA_PROP_TYPE_INT_RANGE: c_int = 1;
pub const PA_PROP_TYPE_INT_ARRAY: c_int = 2;
pub const PA_PROP_TYPE_STRING: c_int = 3;
pub const PA_PROP_TYPE_STRING_ARRAY: c_int = 4;
pub const PA_PROP_TYPE_INVALID: c_int = -1;
pub type pa_prop_type_t = Enum_pa_prop_type_t;
pub enum Struct_pa_operation { }
pub type pa_operation = Struct_pa_operation;
pub type pa_operation_notify_cb_t =
    ::std::option::Option<unsafe extern "C" fn(o: *mut pa_operation,
                                               userdata: *mut c_void)
                              -> ()>;
pub enum Struct_pa_context { }
pub type pa_context = Struct_pa_context;
pub type pa_context_notify_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               userdata: *mut c_void)
                              -> ()>;
pub type pa_context_success_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               success: c_int,
                                               userdata: *mut c_void)
                              -> ()>;
pub type pa_context_event_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               name: *const c_char,
                                               p: *mut pa_proplist,
                                               userdata: *mut c_void)
                              -> ()>;
pub type pa_volume_t = uint32_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_cvolume {
    pub channels: uint8_t,
    pub values: [pa_volume_t; 32usize],
}
impl ::std::clone::Clone for Struct_pa_cvolume {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_cvolume {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_cvolume = Struct_pa_cvolume;
pub enum Struct_pa_stream { }
pub type pa_stream = Struct_pa_stream;
pub type pa_stream_success_cb_t =
    ::std::option::Option<unsafe extern "C" fn(s: *mut pa_stream,
                                               success: c_int,
                                               userdata: *mut c_void)
                              -> ()>;
pub type pa_stream_request_cb_t =
    ::std::option::Option<unsafe extern "C" fn(p: *mut pa_stream,
                                               nbytes: size_t,
                                               userdata: *mut c_void)
                              -> ()>;
pub type pa_stream_notify_cb_t =
    ::std::option::Option<unsafe extern "C" fn(p: *mut pa_stream,
                                               userdata: *mut c_void)
                              -> ()>;
pub type pa_stream_event_cb_t =
    ::std::option::Option<unsafe extern "C" fn(p: *mut pa_stream,
                                               name: *const c_char,
                                               pl: *mut pa_proplist,
                                               userdata: *mut c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_port_info {
    pub name: *const c_char,
    pub description: *const c_char,
    pub priority: uint32_t,
    pub available: c_int,
}
impl ::std::clone::Clone for Struct_pa_port_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_port_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_port_info = Struct_pa_port_info;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_sink_info {
    pub name: *const c_char,
    pub index: uint32_t,
    pub description: *const c_char,
    pub sample_spec: pa_sample_spec,
    pub channel_map: pa_channel_map,
    pub owner_module: uint32_t,
    pub volume: pa_cvolume,
    pub mute: c_int,
    pub monitor_source: uint32_t,
    pub monitor_source_name: *const c_char,
    pub latency: pa_usec_t,
    pub driver: *const c_char,
    pub flags: pa_sink_flags_t,
    pub proplist: *mut pa_proplist,
    pub configured_latency: pa_usec_t,
    pub base_volume: pa_volume_t,
    pub state: pa_sink_state_t,
    pub n_volume_steps: uint32_t,
    pub card: uint32_t,
    pub n_ports: uint32_t,
    pub ports: *mut *mut pa_port_info,
    pub active_port: *mut pa_port_info,
    pub n_formats: uint8_t,
    pub formats: *mut *mut pa_format_info,
}
impl ::std::clone::Clone for Struct_pa_sink_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_sink_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_sink_info = Struct_pa_sink_info;
pub type pa_sink_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i: *const pa_sink_info,
                                               eol: c_int,
                                               userdata: *mut c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_source_info {
    pub name: *const c_char,
    pub index: uint32_t,
    pub description: *const c_char,
    pub sample_spec: pa_sample_spec,
    pub channel_map: pa_channel_map,
    pub owner_module: uint32_t,
    pub volume: pa_cvolume,
    pub mute: c_int,
    pub monitor_of_sink: uint32_t,
    pub monitor_of_sink_name: *const c_char,
    pub latency: pa_usec_t,
    pub driver: *const c_char,
    pub flags: pa_source_flags_t,
    pub proplist: *mut pa_proplist,
    pub configured_latency: pa_usec_t,
    pub base_volume: pa_volume_t,
    pub state: pa_source_state_t,
    pub n_volume_steps: uint32_t,
    pub card: uint32_t,
    pub n_ports: uint32_t,
    pub ports: *mut *mut pa_port_info,
    pub active_port: *mut pa_port_info,
    pub n_formats: uint8_t,
    pub formats: *mut *mut pa_format_info,
}
impl ::std::clone::Clone for Struct_pa_source_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_source_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_source_info = Struct_pa_source_info;
pub type pa_source_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i: *const pa_source_info,
                                               eol: c_int,
                                               userdata: *mut c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_server_info {
    pub user_name: *const c_char,
    pub host_name: *const c_char,
    pub server_version: *const c_char,
    pub server_name: *const c_char,
    pub sample_spec: pa_sample_spec,
    pub default_sink_name: *const c_char,
    pub default_source_name: *const c_char,
    pub cookie: uint32_t,
    pub channel_map: pa_channel_map,
}
impl ::std::clone::Clone for Struct_pa_server_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_server_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_server_info = Struct_pa_server_info;
pub type pa_server_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i: *const pa_server_info,
                                               userdata: *mut c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_module_info {
    pub index: uint32_t,
    pub name: *const c_char,
    pub argument: *const c_char,
    pub n_used: uint32_t,
    pub auto_unload: c_int,
    pub proplist: *mut pa_proplist,
}
impl ::std::clone::Clone for Struct_pa_module_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_module_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_module_info = Struct_pa_module_info;
pub type pa_module_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i: *const pa_module_info,
                                               eol: c_int,
                                               userdata: *mut c_void)
                              -> ()>;
pub type pa_context_index_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               idx: uint32_t,
                                               userdata: *mut c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_client_info {
    pub index: uint32_t,
    pub name: *const c_char,
    pub owner_module: uint32_t,
    pub driver: *const c_char,
    pub proplist: *mut pa_proplist,
}
impl ::std::clone::Clone for Struct_pa_client_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_client_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_client_info = Struct_pa_client_info;
pub type pa_client_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i: *const pa_client_info,
                                               eol: c_int,
                                               userdata: *mut c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_card_profile_info {
    pub name: *const c_char,
    pub description: *const c_char,
    pub n_sinks: uint32_t,
    pub n_sources: uint32_t,
    pub priority: uint32_t,
}
impl ::std::clone::Clone for Struct_pa_card_profile_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_card_profile_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_card_profile_info = Struct_pa_card_profile_info;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_card_profile_info2 {
    pub name: *const c_char,
    pub description: *const c_char,
    pub n_sinks: uint32_t,
    pub n_sources: uint32_t,
    pub priority: uint32_t,
    pub available: c_int,
}
impl ::std::clone::Clone for Struct_pa_card_profile_info2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_card_profile_info2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_card_profile_info2 = Struct_pa_card_profile_info2;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_card_port_info {
    pub name: *const c_char,
    pub description: *const c_char,
    pub priority: uint32_t,
    pub available: c_int,
    pub direction: c_int,
    pub n_profiles: uint32_t,
    pub profiles: *mut *mut pa_card_profile_info,
    pub proplist: *mut pa_proplist,
    pub latency_offset: int64_t,
    pub profiles2: *mut *mut pa_card_profile_info2,
}
impl ::std::clone::Clone for Struct_pa_card_port_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_card_port_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_card_port_info = Struct_pa_card_port_info;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_card_info {
    pub index: uint32_t,
    pub name: *const c_char,
    pub owner_module: uint32_t,
    pub driver: *const c_char,
    pub n_profiles: uint32_t,
    pub profiles: *mut pa_card_profile_info,
    pub active_profile: *mut pa_card_profile_info,
    pub proplist: *mut pa_proplist,
    pub n_ports: uint32_t,
    pub ports: *mut *mut pa_card_port_info,
    pub profiles2: *mut *mut pa_card_profile_info2,
    pub active_profile2: *mut pa_card_profile_info2,
}
impl ::std::clone::Clone for Struct_pa_card_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_card_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_card_info = Struct_pa_card_info;
pub type pa_card_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i: *const pa_card_info,
                                               eol: c_int,
                                               userdata: *mut c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_sink_input_info {
    pub index: uint32_t,
    pub name: *const c_char,
    pub owner_module: uint32_t,
    pub client: uint32_t,
    pub sink: uint32_t,
    pub sample_spec: pa_sample_spec,
    pub channel_map: pa_channel_map,
    pub volume: pa_cvolume,
    pub buffer_usec: pa_usec_t,
    pub sink_usec: pa_usec_t,
    pub resample_method: *const c_char,
    pub driver: *const c_char,
    pub mute: c_int,
    pub proplist: *mut pa_proplist,
    pub corked: c_int,
    pub has_volume: c_int,
    pub volume_writable: c_int,
    pub format: *mut pa_format_info,
}
impl ::std::clone::Clone for Struct_pa_sink_input_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_sink_input_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_sink_input_info = Struct_pa_sink_input_info;
pub type pa_sink_input_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i: *const pa_sink_input_info,
                                               eol: c_int,
                                               userdata: *mut c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_source_output_info {
    pub index: uint32_t,
    pub name: *const c_char,
    pub owner_module: uint32_t,
    pub client: uint32_t,
    pub source: uint32_t,
    pub sample_spec: pa_sample_spec,
    pub channel_map: pa_channel_map,
    pub buffer_usec: pa_usec_t,
    pub source_usec: pa_usec_t,
    pub resample_method: *const c_char,
    pub driver: *const c_char,
    pub proplist: *mut pa_proplist,
    pub corked: c_int,
    pub volume: pa_cvolume,
    pub mute: c_int,
    pub has_volume: c_int,
    pub volume_writable: c_int,
    pub format: *mut pa_format_info,
}
impl ::std::clone::Clone for Struct_pa_source_output_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_source_output_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_source_output_info = Struct_pa_source_output_info;
pub type pa_source_output_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i:
                                                   *const pa_source_output_info,
                                               eol: c_int,
                                               userdata: *mut c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_stat_info {
    pub memblock_total: uint32_t,
    pub memblock_total_size: uint32_t,
    pub memblock_allocated: uint32_t,
    pub memblock_allocated_size: uint32_t,
    pub scache_size: uint32_t,
}
impl ::std::clone::Clone for Struct_pa_stat_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_stat_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_stat_info = Struct_pa_stat_info;
pub type pa_stat_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i: *const pa_stat_info,
                                               userdata: *mut c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_sample_info {
    pub index: uint32_t,
    pub name: *const c_char,
    pub volume: pa_cvolume,
    pub sample_spec: pa_sample_spec,
    pub channel_map: pa_channel_map,
    pub duration: pa_usec_t,
    pub bytes: uint32_t,
    pub lazy: c_int,
    pub filename: *const c_char,
    pub proplist: *mut pa_proplist,
}
impl ::std::clone::Clone for Struct_pa_sample_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_sample_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_sample_info = Struct_pa_sample_info;
pub type pa_sample_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i: *const pa_sample_info,
                                               eol: c_int,
                                               userdata: *mut c_void)
                              -> ()>;
pub type Enum_pa_autoload_type = c_int;
pub const PA_AUTOLOAD_SINK: c_int = 0;
pub const PA_AUTOLOAD_SOURCE: c_int = 1;
pub type pa_autoload_type_t = Enum_pa_autoload_type;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_autoload_info {
    pub index: uint32_t,
    pub name: *const c_char,
    pub _type: pa_autoload_type_t,
    pub module: *const c_char,
    pub argument: *const c_char,
}
impl ::std::clone::Clone for Struct_pa_autoload_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_autoload_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_autoload_info = Struct_pa_autoload_info;
pub type pa_autoload_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i: *const pa_autoload_info,
                                               eol: c_int,
                                               userdata: *mut c_void)
                              -> ()>;
pub type pa_context_subscribe_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               t:
                                                   pa_subscription_event_type_t,
                                               idx: uint32_t,
                                               userdata: *mut c_void)
                              -> ()>;
pub type pa_context_play_sample_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               idx: uint32_t,
                                               userdata: *mut c_void)
                              -> ()>;
pub enum Struct_pa_threaded_mainloop { }
pub type pa_threaded_mainloop = Struct_pa_threaded_mainloop;
pub enum Struct_pollfd { }
pub enum Struct_pa_mainloop { }
pub type pa_mainloop = Struct_pa_mainloop;
pub type pa_poll_func =
    ::std::option::Option<unsafe extern "C" fn(ufds: *mut Struct_pollfd,
                                               nfds: c_ulong,
                                               timeout: c_int,
                                               userdata: *mut c_void)
                              -> c_int>;
pub enum Struct_pa_signal_event { }
pub type pa_signal_event = Struct_pa_signal_event;
pub type pa_signal_cb_t =
    ::std::option::Option<unsafe extern "C" fn(api: *mut pa_mainloop_api,
                                               e: *mut pa_signal_event,
                                               sig: c_int,
                                               userdata: *mut c_void)
                              -> ()>;
pub type pa_signal_destroy_cb_t =
    ::std::option::Option<unsafe extern "C" fn(api: *mut pa_mainloop_api,
                                               e: *mut pa_signal_event,
                                               userdata: *mut c_void)
                              -> ()>;
pub enum Struct_pa_simple { }
pub type pa_simple = Struct_pa_simple;
